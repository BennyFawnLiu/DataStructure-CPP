# 顺序表（Sequential List）- C++ 实现

## 一、什么是顺序表？
顺序表是 **线性表的顺序存储结构**，通过一段连续的内存空间（数组）存储元素，核心特征如下：
- 随机访问：O(1) 时间复杂度获取任意位置元素（直接通过数组索引访问）
- 插入/删除：需移动目标位置后的元素，平均时间复杂度 O(n)
- 空间特性：元素存储紧凑，无额外内存开销（仅占用数组本身空间）
- C++ 实现优势：通过类封装数据与操作，安全性更高，代码复用性强

## 二、核心设计
### 1. 类结构定义
```cpp
class SeqList {
private:
    int elem[MAXSIZE];  // 私有成员：存储元素的数组（默认int类型，可修改）
    int last;           // 私有成员：最后一个元素的索引（空表=-1，满表=MAXSIZE-1）
public:
    SeqList();          // 构造函数：自动初始化空表
    bool isEmpty() const;  // 判空（const修饰，不修改成员变量）
    bool isFull() const;   // 判满
    bool insert(int pos, int value);  // 插入元素
    bool remove(int pos);             // 删除元素
    int search(int value) const;      // 查找元素
    void traverse() const;            // 遍历打印
    int getSize() const;              // 获取元素个数
};
```
- **封装性**：数据（`elem`、`last`）私有化，仅通过公有成员函数操作，避免非法修改
- **构造函数**：创建对象时自动初始化 `last=-1`，无需手动调用初始化函数
- **const 成员函数**：不修改成员变量的函数加 `const`，增强代码安全性和可读性

### 2. 核心功能详解
| 函数名         | 功能描述                     | 输入参数                          | 返回值                | 关键逻辑                                                                 |
|----------------|------------------------------|-----------------------------------|-----------------------|--------------------------------------------------------------------------|
| `SeqList()`    | 初始化空表                   | 无                                | 无                    | 初始化 `last=-1`，标记空表                                               |
| `isEmpty()`    | 判断顺序表是否为空           | 无                                | `true`（空）/`false`  | 直接判断 `last == -1`                                                   |
| `isFull()`     | 判断顺序表是否已满           | 无                                | `true`（满）/`false`  | 判断 `last == MAXSIZE - 1`（与数组索引范围一致）                         |
| `insert()`     | 在指定位置插入元素           | `pos`（插入位置）、`value`（元素值） | `true`（成功）/`false`| 1. 检查表满和位置合法性；2. 从后往前移动元素腾出位置；3. 插入元素并更新 `last` |
| `remove()`     | 删除指定位置元素             | `pos`（删除位置）                 | `true`（成功）/`false`| 1. 检查表空和位置合法性；2. 从删除位置往后移动元素覆盖；3. 更新 `last`    |
| `search()`     | 顺序查找指定值元素           | `value`（待查找值）               | 位置索引（找到）/-1（未找到） | 遍历数组逐一比对元素值                                                   |
| `traverse()`   | 遍历并打印所有元素           | 无                                | 无                    | 遍历数组打印元素，空表给出提示                                           |
| `getSize()`    | 获取当前元素个数             | 无                                | 元素个数（int）       | 直接返回 `last + 1`（无需额外存储长度变量）                              |

### 3. 关键变量说明
- `MAXSIZE`：宏定义的顺序表最大容量（默认100），可直接修改适配不同场景（如改为200、500）
- `last`：核心状态标记，作用如下：
  - 空表判断：`last == -1`
  - 满表判断：`last == MAXSIZE - 1`
  - 元素个数计算：`last + 1`
  - 遍历边界：`i <= last`（避免访问无效内存）

## 三、编译与运行
### 1. 环境依赖
- 编译器：支持 C++11 及以上标准（如 g++、Clang、Visual Studio 2015+、Dev-C++）
- 依赖库：仅使用 C++ 标准库 `<iostream>`，无需额外安装第三方库

### 2. 编译命令（以 g++ 为例）
```bash
# 编译代码（生成可执行文件）
g++ SeqList.cpp -o SeqList -std=c++11

# 运行可执行文件（Windows系统）
SeqList.exe

# 运行可执行文件（Linux/Mac系统）
./SeqList
```

### 3. 运行结果示例
```
=== 测试插入功能 ===
✅ 元素10成功插入到位置0！
✅ 元素20成功插入到位置1！
✅ 元素15成功插入到位置1！
✅ 元素25成功插入到位置3！
❌ 插入位置5不合法！合法范围：0~4
📋 顺序表元素（共4个）：10 15 20 25 

=== 测试查找功能 ===
✅ 元素15找到，位置为1！
❌ 元素30未在顺序表中找到！

=== 测试删除功能 ===
✅ 位置1的元素15成功删除！
❌ 删除位置3不合法！合法范围：0~2
📋 顺序表元素（共3个）：10 20 25 

=== 测试空表删除 ===
✅ 位置0的元素10成功删除！
✅ 位置0的元素20成功删除！
✅ 位置0的元素25成功删除！
❌ 顺序表为空，无元素可删除！
📭 顺序表为空！
```

## 四、常见问题与注意事项
### 1. 为什么空表时 `last = -1`？
- 插入第一个元素时，`pos=0` 是合法位置，插入后 `last=0`，符合 `元素个数=last+1`（1个元素）
- 遍历元素时，循环条件 `i <= last` 空表时直接不执行，逻辑简洁
- 与数组索引规则一致（数组索引从0开始），满表时 `last=MAXSIZE-1` 刚好是数组最后一个索引

### 2. 插入/删除的位置合法性要求
- 插入位置：`0 <= pos <= last + 1`（支持表头、表中、表尾插入）
  - 例：当前有3个元素（`last=2`），合法插入位置为0~3
- 删除位置：`0 <= pos <= last`（不能超过最后一个元素的位置）
  - 例：当前有3个元素（`last=2`），合法删除位置为0~2

### 3. 如何修改存储的数据类型？
默认存储 `int` 类型，如需存储其他类型（如 `double`、`char`、自定义结构体），只需修改两处：
```cpp
// 1. 数组类型修改
double elem[MAXSIZE];  // 改为double类型

// 2. 插入/查找函数的参数类型修改
bool insert(int pos, double value);  // value改为double
int search(double value) const;      // value改为double
```

## 五、扩展方向（进阶学习）
1. **动态扩容**：将静态数组 `elem` 改为动态分配内存（`new[]`/`delete[]`），当表满时自动扩容（如容量翻倍），解决固定容量限制
2. **泛型支持**：使用 C++ 模板（`template <typename T>`），让顺序表支持任意数据类型（无需手动修改数组类型）
3. **迭代器遍历**：实现自定义迭代器，支持 `for-each` 循环遍历（类似 STL 容器）
4. **异常处理**：用 `try-catch` 捕获非法操作（如越界、空表删除），替代 `cerr` 输出，增强错误处理能力
5. **排序与去重**：添加冒泡排序、快速排序等算法，支持有序顺序表；实现去重功能，避免重复元素插入
6. **与 STL vector 对比**：`vector` 是 C++ STL 中的动态顺序表，可对比其扩容机制、接口设计，理解工业级实现的优化点

## 六、学习资源推荐
- 教材：《数据结构（C语言版）》- 严蔚敏（顺序表基础原理）、《C++ Primer》（第5版）- 类与对象章节（C++ 特性）
- 视频课程：王道数据结构 - 线性表（顺序表）、黑马程序员 C++ 数据结构（实战实现）
- 刷题练习：LeetCode 26. 删除有序数组中的重复项（顺序表删除应用）、LeetCode 27. 移除元素（顺序表操作实战）
- 扩展阅读：C++ STL `vector` 源码分析（了解动态顺序表的底层实现）
